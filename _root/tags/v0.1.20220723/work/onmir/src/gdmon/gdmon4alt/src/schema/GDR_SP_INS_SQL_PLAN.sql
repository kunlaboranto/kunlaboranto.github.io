CREATE OR REPLACE PROCEDURE GDR_SP_INS_SQL_PLAN ()
/* INSERT GDR_HIST_SQL_PLAN */
/*
 * TODO: [NOTE]
 * 	(1) FIRST_SQL_CACHE_TEXT_ID 값이, 'NO_SQL_CACHE_STMT' 인 경우 계속 변경
 * 	(2) GDR_HIST_SQL_PLAN 를 UPDATE  하는 로직 추가 - PLAN_HASH_VALUE
 */
is
	V_SQLCODE				NUMBER;
	V_SQLERRM				VARCHAR(2047);
	V_LOGLVL				VARCHAR(64);

    V_LOOP					NUMBER;
    V_COUNT					NUMBER;
    V_CNT					NUMBER;
    V_INS_CNT				NUMBER;
    V_PIECE					VARCHAR(64);
	V_QUERY					VARCHAR(32000);
	V_SQL_TEXT				VARCHAR(32000);
	V_SQL_TEXT2				VARCHAR(32000);
	V_PLAN_TEXT				VARCHAR(32000);
	V_PLAN_TEXT2			VARCHAR(32000);
	V_PLAN_HASH_VALUE		NUMBER;

	--V_SAMPLE_ID             VARCHAR(64);
	V_SAMPLE_TIME           DATE;
	V_SESSION_ID            VARCHAR(64);
	V_USER_NAME				VARCHAR(64);
	V_SQL_ID                VARCHAR(64);
	V_SESSION_STATE         VARCHAR(64);
	V_EVENT                 VARCHAR(64);
	V_WAIT_TIME             VARCHAR(64);
	V_STMT_ID				VARCHAR(64);
	V_SQL_EXEC_START        VARCHAR(64);
	V_TOTAL_TIME            VARCHAR(64);
	V_EXECUTE_TIME          VARCHAR(64);
	V_FETCH_TIME            VARCHAR(64);
	V_EXECUTE_SUCCESS       VARCHAR(64);
	V_GET_PAGE              VARCHAR(64);
	V_READ_PAGE             VARCHAR(64);
	V_CREATE_PAGE           VARCHAR(64);
	V_MODULE                VARCHAR(64);
	V_MACHINE				VARCHAR(64);
	V_PORT                  VARCHAR(64);
	V_SPID                  VARCHAR(64);

	V_SQL_CACHE_TEXT_ID     VARCHAR(64);
	V_SQL_CACHE_PCO_ID      VARCHAR(64);

    cursor C1 is
SELECT /* GDMON */
       --GDR_SQ_SAMPLE_ID.CURRVAL SAMPLE_ID , SYSDATE SAMPLE_TIME,
       SESSION_ID
     , USER_NAME
     , SESSION_STATE
     , EVENT
     , WAIT_TIME
     , STMT_ID
     , SQL_EXEC_START
     --, QUERY
     , SQL_TEXT
     , GDR_SF_PLANTEXT( SESSION_ID, STMT_ID ) PLAN_TEXT
     , SQL_CACHE_TEXT_ID
     , SQL_CACHE_PCO_ID
     , TOTAL_TIME
     , EXECUTE_TIME
     , FETCH_TIME
     , EXECUTE_SUCCESS
     , GET_PAGE
     , READ_PAGE
     , CREATE_PAGE
     , MODULE
     , MACHINE
     , PORT
     , SPID
 FROM 
(
SELECT
       --GDR_SQ_SAMPLE_ID.CURRVAL SAMPLE_ID , SYSDATE SAMPLE_TIME,
       SESSION_ID
     , DB_USERNAME USER_NAME
     , DECODE( EVENT, 'no wait event', 'ON CPU', 'WAITING' ) SESSION_STATE
     , DECODE( EVENT, 'no wait event', NULL, EVENT ) EVENT
     , WAIT_TIME
   --, STATE -- ALLOC / PREPARED / FETCH READY / ..
     , CURRENT_STMT_ID STMT_ID
     , UX2DATE( LAST_QUERY_START_TIME ) SQL_EXEC_START
     --, QUERY
     , GDR_SF_SQLTEXT( SESSION_ID, CURRENT_STMT_ID, QUERY ) SQL_TEXT
   --, GDR_SF_PLANTEXT( SESSION_ID, ID )
   --, TX_ID
     , SQL_CACHE_TEXT_ID
     , SQL_CACHE_PCO_ID
     , TOTAL_TIME
     , EXECUTE_TIME
     , FETCH_TIME
     , EXECUTE_SUCCESS
     , GET_PAGE
     , READ_PAGE
     , CREATE_PAGE
   --, UX2DATE( LOGIN_TIME ) LOGIN_TIME
   --, DELTA_READ_IO_REQUESTS, DELTA_WRITE_IO_REQUESTS, DELTA_READ_IO_BYTES, DELTA_WRITE_IO_BYTES
     , CLIENT_APP_INFO MODULE
     , CASE WHEN COMM_NAME LIKE 'TCP %' THEN SUBSTR( COMM_NAME, 5, INSTR( COMM_NAME, ':' ) - 5 ) ELSE 'localhost' END MACHINE
     , DECODE( INSTR( COMM_NAME, ':' ), 0, 0, SUBSTR( COMM_NAME, INSTR( COMM_NAME, ':' ) + 1, 10 ) ) PORT
     , CASE WHEN CLIENT_TYPE LIKE 'CLI%' THEN CLIENT_PID ELSE NULL END SPID
  FROM V$STATEMENT ST
       INNER JOIN V$SESSION SS ON SS.ID = ST.SESSION_ID AND SS.CURRENT_STMT_ID = ST.ID AND SS.ID <> SESSION_ID()
 WHERE 1=1
   -- 현재 실행중인 것만 조회
   AND ST.EXECUTE_FLAG = 1
   --AND ST.QUERY IS NOT NULL
   --AND (ST.EXECUTE_FLAG = 1 OR SS.TASK_STATE = 'EXECUTING')
   --AND LENGTHB(ST.QUERY) < 16000
   -- [NOTE] add for just gathering time 
   AND ( 1=0
      OR SQL_CACHE_TEXT_ID = 'NO_SQL_CACHE_STMT'
      OR SS.ID ||'_' ||ST.ID IN ( SELECT MAX(SS.ID ||'_' ||ST.ID) FROM V$STATEMENT ST INNER JOIN V$SESSION SS ON SS.ID = ST.SESSION_ID AND SS.CURRENT_STMT_ID = ST.ID AND SS.ID <> SESSION_ID() WHERE ST.EXECUTE_FLAG = 1 GROUP BY SQL_CACHE_TEXT_ID )
       )
   --AND NOT EXISTS ( SELECT 1 FROM GDR_HIST_SQL_PLAN WHERE FIRST_SQL_CACHE_TEXT_ID = ST.SQL_CACHE_TEXT_ID )
   AND NOT EXISTS ( SELECT 1 FROM GDR_HIST_SQL_PLAN WHERE FIRST_SQL_CACHE_TEXT_ID = DECODE( ST.SQL_CACHE_TEXT_ID, 'NO_SQL_CACHE_STMT', 'X', ST.SQL_CACHE_TEXT_ID ) AND CREATED > TRUNC(SYSDATE) )
) A
 WHERE 1=1
   --AND NOT EXISTS ( SELECT 1 FROM GDR_HIST_SQL_PLAN WHERE SQL_ID = GDR_SF_SQL_ID( A.SQL_TEXT ) )
   AND NOT EXISTS ( SELECT 1 FROM GDR_HIST_SQL_PLAN WHERE SQL_ID = GDR_SF_SQL_ID( A.SQL_TEXT ) AND CREATED > TRUNC(SYSDATE) ) 
;

	-- 500 = 32000 / 64
	-- TODO: [OKT] Max 32000 * 2
	CURSOR C2 IS SELECT /* GDMON */ TEXT FROM  V$SQLTEXT WHERE SID = V_SESSION_ID AND STMT_ID = V_STMT_ID ORDER BY PIECE LIMIT 501, 500 ;
	CURSOR C3 IS SELECT /* GDMON */ TEXT FROM V$PLANTEXT WHERE SID = V_SESSION_ID AND STMT_ID = V_STMT_ID ORDER BY PIECE LIMIT 501, 500 ;

	V_STM				DATE;
	V_DTM				NUMBER(15,6);	-- MICROSECOND

BEGIN
	V_SQLCODE := 0;
	V_SQLERRM := ' ';
	V_STM := SYSDATE;
	V_DTM := 0;

SYSTEM_.PRINTLN(NULL);
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - START !!');

	--SELECT GDR_SQ_SAMPLE_ID.NEXTVAL, SYSDATE INTO V_SAMPLE_ID, V_SAMPLE_TIME FROM DUAL;

    OPEN C1;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-01) ');

	V_LOOP := 0;
	V_INS_CNT := 0;
    LOOP
		V_LOOP := V_LOOP + 1;
		V_PLAN_HASH_VALUE := NULL;
		V_SQL_ID := NULL;
		V_SQL_TEXT := NULL;
		V_SQL_TEXT2 := NULL;
		V_PLAN_TEXT := NULL;
		V_PLAN_TEXT2 := NULL;

        FETCH C1 INTO V_SESSION_ID
					, V_USER_NAME
					, V_SESSION_STATE
					, V_EVENT
					, V_WAIT_TIME
					, V_STMT_ID
					, V_SQL_EXEC_START
					--, V_QUERY
					, V_SQL_TEXT
					, V_PLAN_TEXT
					, V_SQL_CACHE_TEXT_ID
					, V_SQL_CACHE_PCO_ID
					, V_TOTAL_TIME
					, V_EXECUTE_TIME
					, V_FETCH_TIME
					, V_EXECUTE_SUCCESS
					, V_GET_PAGE
					, V_READ_PAGE
					, V_CREATE_PAGE
					, V_MODULE
					, V_MACHINE
					, V_PORT
					, V_SPID ;
        EXIT WHEN C1%NOTFOUND;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-02) , V_LOOP='||V_LOOP);

		IF LENGTHB( V_PLAN_TEXT ) = 64 THEN
			V_PLAN_TEXT := NULL;
		END IF;

		-- 동시성으로 SQL도 못가져오는 경우가 있을까?
		IF V_SQL_TEXT IS NULL THEN
		-- TODO: [OKT] PLAN없이 SQL 만 있는 경우도 수집한다.
		--IF V_SQL_TEXT IS NULL OR V_PLAN_TEXT IS NULL THEN
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-03), SQL_ID=['||V_SQL_ID||'] WHY V_SQL_TEXT IS NULL !! ('||RPAD(V_QUERY,40)||')');
			CONTINUE;
		END IF;

		-- 성능상, 매번 PLAN을 얻지 않고, 1일 1회만 확인한다.
		V_SQL_ID := GDR_SF_SQL_ID( V_SQL_TEXT ) ;
		V_PLAN_HASH_VALUE := GDR_SF_SQL_ID( V_PLAN_TEXT ) ;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-04), SQL_ID=['||V_SQL_ID||']');

		SELECT COUNT(*) INTO V_COUNT 
		  FROM GDR_HIST_SQL_PLAN 
		 WHERE USER_NAME = V_USER_NAME
		   AND SQL_ID = V_SQL_ID
		   AND PLAN_HASH_VALUE = V_PLAN_HASH_VALUE
		;

		-- TODO: [OKT] HIT 횟수나, 마지막 호출 시간을 갱신할 수도 있다 
		IF V_COUNT != 0 THEN
			-- 이미 등록됨
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-05), CHECK (DUP-SKIP), '||V_SESSION_ID||','||V_STMT_ID||','||V_SQL_CACHE_TEXT_ID );
			CONTINUE;
		END IF;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-06), CHECK (NEW)');

		--{
		--IF LENGTHB( V_SQL_TEXT ) > 16380 THEN -- 16384 (X)
		IF LENGTHB( V_SQL_TEXT ) >= 32000 THEN -- 16384 (X)
			OPEN C2;
			LOOP
				FETCH C2 INTO V_PIECE;
				EXIT WHEN C2%NOTFOUND;

				V_SQL_TEXT2 := V_SQL_TEXT2 || V_PIECE ;
			END LOOP;
			CLOSE C2;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-07), SQL_TEXT2 (NEW)');
		END IF;

		--TODO: [OKT] WHY LEN > 31101 ?
		--IF LENGTHB( V_PLAN_TEXT ) > 16380 THEN -- 16384 (X)
		IF LENGTHB( V_PLAN_TEXT ) >= 31101 THEN -- 16384 (X)
			OPEN C3;
			LOOP
				FETCH C3 INTO V_PIECE;
				EXIT WHEN C3%NOTFOUND;

				V_PLAN_TEXT2 := V_PLAN_TEXT2 || V_PIECE ;
			END LOOP;
			CLOSE C3;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-08), PLAN_TEXT2 (NEW)');
		END IF;

		V_INS_CNT := V_INS_CNT + 1 ;
		INSERT INTO GDR_HIST_SQL_PLAN
			( USER_NAME, SQL_ID, PLAN_HASH_VALUE, FIRST_SQL_CACHE_TEXT_ID, FIRST_SESSION_ID, FIRST_STMT_ID, FIRST_MODULE, FIRST_MACHINE, FIRST_PORT, FIRST_SPID, SQL_TEXT, SQL_TEXT2, PLAN_TEXT, PLAN_TEXT2 
			)
		VALUES
			( V_USER_NAME, V_SQL_ID, V_PLAN_HASH_VALUE, V_SQL_CACHE_TEXT_ID, V_SESSION_ID, V_STMT_ID, V_MODULE, V_MACHINE, V_PORT, V_SPID, V_SQL_TEXT, V_SQL_TEXT2, V_PLAN_TEXT, V_PLAN_TEXT2 
			)
		;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - (OKT-09), INSERT (NEW)');
		--}

		/*
		INSERT INTO GDR_ACTIVE_SESSION_HISTORY 
			( SAMPLE_ID, SAMPLE_TIME, SESSION_ID, USER_ID, SQL_ID, SQL_CHILD_NUMBER, PLAN_HASH_VALUE
		-- , SESSION_STATE, BLOCKING_SESSION
		-- , EVENT, EVENT_ID, P1TEXT, P1, WAIT_CLASS, WAIT_CLASS_ID, WAIT_TIME, TIME_WAITED
		-- , MODULE, MACHINE, PORT, FLAGS 
		*/

    END LOOP;
    CLOSE C1;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - LOOP-END !!');

	--ROLLBACK;
	COMMIT;
V_STM := GDR_SF_CHECKTIME( V_STM, V_DTM ); SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ['||V_DTM||'] GDR_SP_INS_SQL_PLAN - END !!');

EXCEPTION
    WHEN OTHERS THEN
		V_SQLCODE := SQLCODE ;
		V_SQLERRM := SQLERRM ;
		--SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] [ERROR] GDR_SP_INS_SQL_PLAN - A_SAMPLE_ID = '||A_SAMPLE_ID );
		SYSTEM_.PRINTLN('['||TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS.FF6')||'] ERR-'||V_SQLCODE||' '||V_SQLERRM );

		CLOSE C1;	-- ERR-1104E : One or more statement exists. 
		ROLLBACK;
		RAISE_APPLICATION_ERROR( 990000 + MOD(V_SQLCODE,1000) , V_SQLERRM );	-- ALTIBASE ( 990000 ~ 991000 )
END;
/
